OOPS Concept

class - Class is a blueprint for object.
	class has attribute and methods. 
	Attributes are like properites and method is like what all it can do.
	e.g.: attributes: Bike color, mielage, engine cc, tyre size etc.
		methods: How bike starts, stops, how engine starts.

Object- Object is a instance of a class.

How to create class and object? 
	class Student:
		name = rahul
	
	s1 = Student()
	s1.name ==> rahul

Constructor - All classes have a function called __init__(), which gets 
	excuted whenever the object is created.

	class Student:
		def __init__(self,fullname):
			self.name = fullname

	s1 = Student('Amit')
	s1.name ==> 'Amit'

self -The self parameter is a reference to the current instance of the class.
      It is used to access variables that belongs to the class.


class & object attributes
object attributes are those which are defined with self.
Object attribute is created and occupies space whenever a new object is 
created. 
	e.g. self.name = name
	

class attribute is set only once when class is defined Or when the script is 
run and dont use self.
 
Value of attribute remains same for all objects.
	e.g.: 
	class Student:
		college = 'IITB'
		def __init__(self,fullname):
			self.name = fullname

	s1 = Student()
	s1.college ==> 'IITB'

What are three types of method in class?
Static Method
Class Method
Instance Method - Normal methods that use self.

Static  Methods
Methods that dont use the self parameter (works at class level).
static methods cannot modify object, class attributes. Also cannot access 
class methods. 
Used when we want to use function which wont change for any object.

How to define static methods in class?
class Student:
	@staticmethod
	def college():
		print('IITB college')

	//here college is a static method.
	//Should use @staticmethod decorator, if not using self in parameter.

How to change class attributes ?
	class Student:
		name = 'anonymous'
		def changeName(self,name):
			self.name = name
	p1 = Person()
	p1.changeName(Amit)
	print(p1.name, Person.name) ==> (Amit, anonymous)
	// didnt change class atribute 
		
		def changeName(self,name):
			Person.name = name

	print(p1.name, Person.name) ==> (Amit, Amit)
	// changed class atribute. 
	// Also, .__class__.name will change.
			
		def changeName(self,name):
			self.__class__.name = name

Another way to change class atributes is by using class methods.

Class Method - class Method is defined inside the class which take class as 
	a 1st argument. 
It use decorator @classmethod
Used when we want to chnage only class attributes.	
	e.g.: 
	class Student:
		name = anonymous
		@classmethod
		def  changeName(cls,name):
			cls.name = name

	print(p1.name, Person.name) ==> (Amit, Amit)

Other decorators:
@property
getter
setter

Four pillars of oops:
Abstraction - Hiding the implementation details of a class and only showing 
essential features to the user.
	e.g. car owner has access to s1.start() function but dont know how 
		this method is implemnted in class.

Encapsulation - Wrapping data and functions into single unit.
		e.g. encapsulation is done in class (bundles attibutes
		and methods together). 
		Object uses that encapsulation.


del - del keyword is used to delete object properties or object itself.


private attributes and methods
Private attribute and methods are meant to be used only within the
class and not accessible from outside the class.

to create private attribute, methods use __ double underscore.
e.g.: 
	class Person:
		__name == 'anonymous'
		def __hello(self):
			print('hello person named', __name)
		def welcome(self):
			self.hello()
	p1 = Person()
	print(p1.welcome())

	// Here __name is private attritbute. __hello is private method.


Inheritance - When one class derives the properties and methods of another 
	class.
	e.g.: R.E. bikes has defined logic for start, stop. Then these
		same methods can be inherited for another bikes.
Types: 
	Single, Multi, Multiple 

super() - super() method is used to access methods of the parent class.
	e.g.:
	class Bike:
		def __init__(self, type): 
			self.type = type
		@staticmethod
		def start():
			print('bike started')
		@staticmethod
		def stop():
			print('bike stoped')
	
	class RoyalEnfield(Bike):
		def __init__(self, name, type):
			super().__init__(type)
			self.name = name
			// super().start() can also call other functions
	
	b1 = RoyalEnfield(Himaliyan, NonElectric)


Polymorphism - Same operator having different meaning in differnet context.
	e.g.: +
	we can also change the meaning of + using dundder methods. 
	def __add__() in class. Also, can do for other opeartors.

*method oveloading
*method overridding



	



